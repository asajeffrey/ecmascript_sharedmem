# A WIP memory model

This directory contains a WIP memory model for ECMAScript shared memory and atomics.

This README contains notes summarizing the memory model.

## Introduction

The SharedArrayBuffer proposal for ECMAScript allows byte arrays to be
shared amongst workers. This is particularly significant for asm.js
programs, since it allows multi-threaded C programs to be compiled via
LLVM to asm.js, and for C threads communicating via shared memory to
be compiled to workers communicating via a SharedArrayBuffer.

The proposed ECMAScript API for shared memory supports two kinds of
accesses: *atomic* and *non-atomic*. Atomic accesses are required to
be sequentially consistent, and are implemented using synchronizing
mechanisms such as fences or locks. Non-atomic accesses have much
weaker consistency requirements, and are implemented without any
synchronization.

In this note, we propose a WIP memory model suitable for ECMAScript.
It is designed to be as close as possible to the C/C++11 and LLVM
memory models, to support both compilation from LLVM to asm.js, and to
support implementing SharedArrayBuffer in languages such as C/C++ or
Rust. The model can be simpler than the C/C++11 or LLVM models, since
it has fewer types of access, and in particular does not have undefined
behaviours or values.

The model is similar to the C/C++11 or LLVM model, in that it is based
on byte read and write events, equipped with two relations:

* the *happens before* relation, where *d* happens before *e*
  whenever compiler or hardware reorderings of loads and stores
  are required to keep *d* before *e*.

* the *reads from* function, where *d* reads from *e*
  whenever *d* is a read event, and *e* is its justifying write event.

Most of the memory model is inherited from LLVM or C/C++11.  The main
difference is how tearing is treated. We could ban all tearing, but
this is too strong, as it disallows any implementation where the
synchronization mechanism for values larger than a machine word is
different from that smaller ones.  For example, on a 32-bit
architecture, atomic 64-bit accesses might be implemented using a
global lock, whereas 32-bit accesses might be implemented using
appropriate machine instructions. For this reason, rather than
disallow tearing on all atoms, we disallow tearing on events with the
same address range.

The proposed memory model has three requirements of program executions:

* *per-range isolation*: there is no tearing generated by
  atomic loads and stores to the same address range,

* *per-byte sequential consistency*: atomic byte read and write events
  are sequentially consistant, and

* *thin-air-read-free*: there are no cycles in the
  combined data- and control-flow of the program,
  so no values come out of thin air.

The requirements of per-byte sequential consistency and
thin-air-read-freedom are essentially the same as in LLVM
or C/C++11, the novelty is how per-range isolation specifies
the behaviour of atomic load and store operations without
hardware support.

We wish to avoid having to make changes to the language specification
except where inter-thead communication is involved. For this reason,
we make few requirements about the host language: for each thread
we ask for its collection of events, with *program order* and
*data dependency* relations on events.

## Preliminaries

The *inverse* of a relation ─R→ is the relation ←R─ defined as
*d* ←R─ *e* whenever *e* ─R→ *d*.

The *kernel* of a relation ─R→ is the relation ←R→ defined to be
*d* ←R→ *e* whenever *d* ←R─ *e* ─R→ *d*.

A relation ─R→ is *reflexive* whenever for any *e* we have *e* ─R→ *e*.

A relation ─R→ is *symmetric* whenever *d* ─R→ *e* implies *d* ←R─ *e*.

A relation ─R→ is *transitive* whenever *c* ─R→ *d* ─R→ *e* implies *c* ─R→ *e*.

A relation ─R→ is *antisymmetric* whenever *d* ←R→ *e* implies *d* = *e*.

A relation ─R→ is *total* whenever for any *d* and *e*, either
*d* ─R→ *e* or *e* ─R→ *d*.

A *pre-order* is a reflexive, transitive relation.

A *partial order* is an antisymmetric pre-order.

A *total order* is a total partial order.

A *partial equivalence* is a symmetric, transitive relation.

An *equivalence* is a total partial equivalence.

## Host language requirements

The host language of interest is ECMAScript, but the model is defined for
any language which can provide appropriate executions consisting of
*events* and *data dependencies*.

In examples, we use a simple imperative language with a shared array `m`, and write:

* `m[i]` for a non-atomic read,
* `m[i] = e` for a non-atomic write,
* `m[i..j]` for an atomic read,
* `m[i..j] = [eᵢ,⋯,eⱼ]` for an atomic write, and
* `m[i..j] = op(m[i..j])` for an atomic update such as increment or CAS.
* `T₁ ∥ ⋯ ∥ Tₙ` for the parallel composition of `n` threads `T₁` to `Tₘ`.

The memory model is defined using a alphabet of *actions*, which are
individual byte reads and writes.

**Definition**: The *alphabet* Σ is the set consisting of:

* *read actions*: `R m[i] = v`, and
* *write actions*: `W m[i] = v`,

where `m[i]` is an index in a shared memory, and `v` is a byte value
We call `m[i]` the *location* of an action, and `v` the *value* of an action. ∎

We are mostly treating thread executions as black boxes, but we are
interested in the sequence of labelled events that each execution
participates in, together with a notion of which events are atomic,
and a data dependency relation on those
events.  We write *d* ─po→ *e* when event *d* precedes event *e* in
program order, *d* ←po→ *e* when *d* and *e* must be executed simultaneously,
and *d* ─dd→ *e* when event *e* depends on event *d*.
In examples, we will often use the event labels to stand in for the events
(with subscripts if necessary to disambiguate), and write
[*e*₁,⋯,*eₙ*] when *e*₁ ←at→ ⋯ ←at→ *eₙ*.

For example, an execution of `x = m[0]; y = m[1]; m[0] = 1; m[1] = x;`
(where all accesses are non-atomic) is:

> `R m[0] = 1` ─po→ `R m[1] = 1` ─po→ `W m[0] = 1` ─po→ `W m[1] = 1`
>
> `R m[0] = 1` ─dd→ `W m[1] = 1`

and an execution of `x = m[0]; y = m[1]; m[0] = 1; m[1] = x;`
(the same thread, but with atomic accesses) is:

> [`R m[0] = 1`,`R m[1] = 1`] ─po→ [`W m[0] = 1`,`W m[1] = 1`]
>
> `R m[0] = 1` ─dd→ `W m[1] = 1`

**Definition**: a *thread execution* is a 5-tuple (*E*, λ, ←at→, ─po→, ─dd→) where:

* *E* a set of *events*,
* λ : (*E* → Σ) is a *labelling*,
* ←at→ ⊆ (*E* × *E*) is the *same-atom* partial equivalence,
* ─po→ ⊆ (*E* × *E*) is the *program order* total order,
* ─dd→ ⊆ ─po→ is the *data dependency* relation,

such that:

* if *c* ─po→ *d* ─po→ *e* and *c* ←at→ *e* then *c* ←at→ *d* ←at→ *e*.

Define:

* the set of *atomic events*, *A* is { *e* | *e* ←at→ *e* },
* the set of *read events*, *R*, is { *e* | λ(*e*) is a read action },
* the set of *write events*, *W*, is { *e* | λ(*e*) is a write action },
* the *value* of an event, val(*e*), is the value of λ(*e*),
* the *location* of an event, loc(*e*) is the location of λ(*e*),
* the *location range* of an atomic event, range(*e*), is { loc(*d*) | *d* ←at→ *e* }, and
* the *size* of an atomic event is the size of its location range. ∎

Note that the host language implementation has a lot of freedom in defining data dependency.
[We will put some sanity conditions on ─dd→ to ensure SC-DRF, which will look
a lot like non-interference.]

In practice, languages will place limits on location ranges,
for example allowing {`m[i]`,`m[j]`} only when `i == j+1` or `j == i+1`,
but this does not impact the memory model.

## Memory model

Given a thread execution for each thread in the program,
we would like to know when they can be combined to form a program
execution. A *candidate execution* is one where we combine together
the individual thread executions.

**Definition** Given *n* thread executions define a *candidate program execution* to be
(*E*, ─hb→, ─rf→) where:

* ─hb→ = (─po→ ∪ ─sw→)* is the *happens before* partial order, and
* ←rf─ : *R* → *W* is the *reads from* function,

such that if *c* ─rf→ *e* then:

* *c* has the same location and value as *e*,
* we do not have (*e* ─hb→ *c*), and
* there is no (*c* ─hb→ *d* ─hb→ *e*) where *d* writes to the same location as *e*,

where we define:

* *E* = (*E*₁ ∪ ⋯ ∪ *Eₙ*) (wlog we assume the *Eᵢ* are disjoint),
* *A* = (*A*₁ ∪ ⋯ ∪ *Aₙ*),
* ─dd→ = (─dd→₁ ∪ ⋯ ∪ ─dd→ₙ),
* ─po→ = (─po→₁ ∪ ⋯ ∪ ─po→ₙ), and
* ─sw→ = (─rf→ ∩ (*A* × *A*)). ∎

Some candidate program executions are invalid, however, for three possible reasons:
tearing, sequential inconsistency, or thin-air read.

We could ban all tearing between all atomic events, by requiring that
for any *b* ─sw→ *c* ←at→ *d* ←sw─ *e*, we have *b* ←at→ *d*.
This requirement makes sense in typed
languages, but it is too strong a requirement in the presence of
operations acting on the same location at different data sizes.

For example, consider the program:
```
    m[0..7] = [0,0,0,0,0,0,0,0]; m[0..7] = [1,2,3,4,5,6,7,8];
  ∥ [x,y] = m[2..3];
```

All executions include:

> [`W m[0] = 0`, ⋯ , `W m[7] = 0`] ─hb→ [`W m[0] = 1`, ⋯ ,`W m[7] = 8`]  
> [`R m[2] = v`, `R m[3] = w`]  

and there are executions which do not exhibit tearing, for example reading all zeros:

> `W m[2] = 0` ─rf→ `R m[2] = 0`  
> `W m[3] = 0` ─rf→ `R m[3] = 0`  

or reading no zeros:

> `W m[2] = 3` ─rf→ `R m[2] = 3`  
> `W m[3] = 4` ─rf→ `R m[3] = 4`  

These executions do not exhibit tearing, since
every read atom is reading from just one write atom.
An execution which includes tearing is:

> `W m[2] = 0` ─rf→ `R m[2] = 0`  
> `W m[3] = 4` ─rf→ `R m[3] = 4`  

This execution would be disallowed by memory models in which all
atomic accesses use the same synchronization mechanism, in particular
where all atomic accesses use hardware atomic instructions. However,
implementations may use different sychronization for different data
sizes, for example using mutexes for accesses larger than one machine
word.

**Definition** A candidate program execution is *per-range isolated*
if, whenever *b* ─sw→ *c* ←at→ *e* ←sw─ *d* and *b*, *c*, *d* and *e*
all have the same location range, then *b* ←at→ *d*. ∎

Next, consider the classic TAR pit program `m[0] = m[1]; ∥ m[1] = m[0];`,
which has the candidate execution:

>  `W m[1] = 1` ─rf→ `R m[1] = 1` ─dd→ `W m[0] = 1` ─rf→ `R m[0] = 1` ─dd→ `W m[1] = 1`

This execution is considered invalid because the value `1` has come
from thin air. Allowing such executions breaks invariant reasoning,
for example type safety.

However, in the companion program `m[0] = m[1]; ∥ m[1] = 1;`,
we do want to allow a similar execution:

>  `W m[1] = 1` ─rf→ `R m[1] = 1` ─dd→ `W m[0] = 1` ─rf→ `R m[0] = 1`

The difference between these two executions is that in the TAR pit, we have
a cycle between ─rf→ and ─dd→, but the matching execution in the companion
does not have `R m[0] = 1` ─dd→ `W m[1] = 1`, breaking the cycle.

**Definition** A candidate program execution is *thin-air-read-free* if
(─dd→ ∪ ─rf→)* is a partial order.

[Note: can we use dd rather than hb here? Do we need a definition of preserved hb?]

Finally, we want atomic memory accesses to be sequentially consistent.
For example, in the independent-read independent-write example:
```
    m[0..0] = [1];
  ∥ m[0..0] = [2];
  ∥ [a] = m[0..0]; [b] = m[0..0];
  ∥ [c] = m[0..0]; [d] = m[0..0];
```
has candidate execution:

> [`W m[0] = 1`]  
> [`W m[0] = 2`]  
> [`R m[0] = 1`]₁ ─hb→ [`R m[0] = 2`]₁  
> [`R m[0] = 2`]₂ ─hb→ [`R m[0] = 1`]₂  
>
> [`R m[0] = 1`]₁ ⟵rf─ [`W m[0] = 1`] ─rf→ [`R m[0] = 1`]₂  
> [`R m[0] = 2`]₁ ⟵rf─ [`W m[0] = 2`] ─rf→ [`R m[0] = 2`]₂  

which is sequentially inconsistent, since there is disagreement
between the threads about whether the writes happened in the order `1, 2`
or `2, 1`.

**Definition** A candidate program execution is *per-byte sequentially consistent* if
there is a total order ─mo→ ⊆ (*A* × *A*) such that:

* if *d* ─hb→ *e* then *d* ─mo→ *e*, and
* if *c* ─rf→ *e* then there is no (*c* ─mo→ *d* ─mo→ *e*) where *d* writes to the same location as *e*. ∎

**Definition** A *program execution* is a candidate program execution which is
per-range isolated, thin-air-read-free and per-byte sequentially consistent.

## Compilation to and from LLVM or C/C++ atomics

The mapping from ECMAScript accesses to C/C++ accesses is:

* ECMAScript non-atomic to C/C++ relaxed
* ECMAScript atomic to C/C++ sequentially consistent

The mapping from C/C++ accesses to ECMAScript accesses is:

* C/C++ non-atomic to ECMAScript non-atomic
* C/C++ relaxed to ECMAScript atomic
* C/C++ acquire/consume/release to ECMAScript atomic
* C/C++ sequentially consistent to ECMAScript atomic

The mapping from ECMAScript accesses to LLVM accesses is:

* ECMAScript non-atomic to LLVM unordered
* ECMAScript atomic to LLVM sequentially consistent

The mapping from LLVM accesses to ECMAScript accesses is:

* LLVM non-atomic to ECMAScript non-atomic
* LLVM unordered to ECMAScript non-atomic
* LLVM monotonic to ECMAScript atomic
* LLVM acquire/consume/release to ECMAScript atomic
* LLVM sequentially consistent to ECMAScript atomic

**Note**: C/C++ relaxed and LLVM monotonic are mapped to ECMAScript atomic because relaxed
accesses are required to be per-location sequentially consistent, and
ECMAScript non-atomics are not.

A common execution path is for a C program to be compiled to asm.js,
then executed in a run-time environment implemented in C. In this
case, a non-atomic access in the original program will be executed as
relaxed, but any other access in the original program will be executed
as sequentially consistent.

In the (hopefully unlikely) case that a program is
compiled from C to ECMAScript to C to ECMAScript to C, every memory
access in the original program will become sequentially consistent.

The requirement that program executions are per-byte sequentially consistent
constrains the implementation in the case that it has to use locks to
implement atoms whose data size is large than one machine word.
Inside the critical section, accesses have to be sequentially consistent,
not just relaxed.

[TODO: do we want to relax this requirement?]

## TODO

Still to do:

* Define the ECMAScript alphabet.
* Define the restrictions on ←po→ for ECMAScript.
* Give semantics for the shared arrays API in terms of events.
* Give semantics for other inter-thread communication mechanisms such as message channels.
* Give examples of non-aligned access, and varying word sizes.
* Formalize the non-interference property for dd, and show SC-DRF.
